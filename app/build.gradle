//载入插件 使用的是apply函数，apply支持from、plugin、to
//apk 必须加载这个插件
apply plugin: 'com.android.application'
//kotlin插件
apply plugin: 'kotlin-android'
//kotlin绑定控件插件
apply plugin: 'kotlin-android-extensions'

android {
    compileSdkVersion 26
    defaultConfig {
        applicationId "org.joker.gear"
        minSdkVersion 19
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        externalNativeBuild {
            cmake {
                cppFlags ""
            }
        }
    }
    /*
    buildTypesScriptBlock.
    buildTypes和signingConfigs，当我们在build.gradle中通过{}配置它的时候，
    其背后的所代表的对象是NamedDomainObjectContainer<BuildType> 和
    NamedDomainObjectContainer<SigningConfig>
    注意，NamedDomainObjectContainer<BuildType/或者SigningConfig>是一种容器，
    容器的元素是BuildType或者SigningConfig。我们在debug{}要填充BuildType或者
    SigningConfig所包的元素，比如storePassword就是SigningConfig类的成员。而proguardFile等
    是BuildType的成员。
    那么，为什么要使用NamedDomainObjectContainer这种数据结构呢？因为往这种容器里
    添加元素可以采用这样的方法： 比如signingConfig为例
    signingConfig{//这是一个NamedDomainObjectContainer<SigningConfig>
       test1{//新建一个名为test1的SigningConfig元素，然后添加到容器里
         //在这个花括号中设置SigningConfig的成员变量的值
       }
      test2{//新建一个名为test2的SigningConfig元素，然后添加到容器里
         //在这个花括号中设置SigningConfig的成员变量的值
      }
    }
    在buildTypes中，Android默认为这几个NamedDomainObjectContainer添加了
    debug和release对应的对象。如果我们再添加别的名字的东西，那么gradleassemble的时候
    也会编译这个名字的apk出来。比如，我添加一个名为debug2的buildTypes，那么gradle assemble
    就会编译一个xxx-debug2-yy.apk
    */
    signingConfigs {
        release {
            storeFile file("./gearkotlin.jks")
            storePassword 'q110q110'
            keyAlias("jokergear")
            keyPassword '110q110q'
        }
        debug {
            storeFile file("./gearkotlin.jks")
            storePassword 'q110q110'
            keyAlias("jokergear")
            keyPassword '110q110q'
        }
    }
    //build配置
    buildTypes {
        release {
            minifyEnabled false
            //混淆设置
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
        debug {
            signingConfig signingConfigs.debug
        }
        debug2 {
            signingConfig signingConfigs.debug
        }
    }
    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }
    productFlavors {
    }
}
/*
这里注意compile被标记过时，通过两个新指令代替
api：完全等同于compile指令，没区别
implementation：对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，
也就是将该依赖隐藏在内部，而不对外部公开，如果你的appModel中有使用依赖那么需要使用api指令对全局开放
 */
dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"
    implementation 'com.android.support:appcompat-v7:26.1.0'
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.1'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
}
